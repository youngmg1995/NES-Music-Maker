# -*- coding: utf-8 -*-
"""
Created on Wed Apr  8 21:29:08 2020

@author: Mitchell

generation_utils.py
~~~~~~~~~~~~~~~~~~~
This file contains helper functions used to generate original NES music
using our trained VAE model. Primarily it contains the following functions:
    
    1) generate_seprsco:
    - Parses outputs generated using our VAE model into valid seprsco files
    for NESM soundtracks.
    
    2) latent_SVD:
    - Function used for effectively sampling from our latent space. Uses
    SVD of latent vectors for training examples to sample from orthogonal
    components of distributions over each latent variable.
    
"""

import numpy as np
import matplotlib.pyplot as plt


def generate_seprsco(tracks, int2labels_map):
    '''
    This function is used to parse the outputs of our VAE model into valid
    seprsco data formats. This format can easily be converted into a format for
    playing on the NES or to WAV audio for listening to.

    Parameters
    ----------
    tracks : numpy arrays
        The output sequence(s) generated by our reduced VAE.
    int2labels_map : numpy array
        This is the inverse mapping used to de-vectorize our sequence.
        More simply, it maps our sequence back to the original label values 
        from the integer representations.

    Returns
    -------
    seprsco_tracks : list of tuples
        List containing each valid seprsco track extracted from our input
        sequence.

    '''
    # Grab # of tracks
    n = tracks.shape[0]
    
    # Flatten each track to single array
    flat_tracks = tracks.reshape((n,-1))
    
    # Devectorize track using int2labels_map
    flat_tracks = int2labels_map[flat_tracks]
    
    # Initialize array to store seprsco formatted tracks
    seprsco_tracks = []
    
    # Iterate over tracks to reformat as seprsco
    for track in flat_tracks:
        score = np.zeros((track.shape[0],4), np.uint8)
        score[:,0] = track
        nsamps = 1839 * score.shape[0]
        rate = 24.0
        seprsco_tracks.append((rate, nsamps, score))
        
    return seprsco_tracks


def latent_SVD(latent_vecs, rand_vecs, plot_eigenvalues = True):
    '''
    Function used for effectively sampling from our latent variable space.
    Uses singular value decomposition, SVD, of the latent vectors for our
    training dataset to sample from the orthogonal components of the
    distribution over our latent variables.

    Parameters
    ----------
    latent_vecs : numpy array or tensorflow Tensor
        Compressed latent valaues for each sample in our training dataset,
        or whatever dataset we want to model our generated outputs from.
    rand_vecs : numpy array or tensorflow Tensor
        Random samples drawn from normal distribution use to generate latent
        samples.
    plot_eigenvalues : Boolean, optional
        Boolean passed to plot eigenvalues of SVD. The default is True.

    Returns
    -------
    sample_vecs : numpy array
        Sample vectors from latent space.

    '''
    # Perform SVD
    latent_means = np.mean(latent_vecs, axis=0)
    latent_stds = np.std(latent_vecs, axis=0)
    latent_cov = np.cov((latent_vecs - latent_means).numpy(),rowvar=False)
    u, s, v = np.linalg.svd(latent_cov)
    e = np.sqrt(s)
    
    # Plot Eignevalues
    if plot_eigenvalues:
        plt.figure()
        plt.bar(range(1,len(e)+1), e)
        plt.xlabel('Latent Space Component')
        plt.ylabel('Eigenvalue')
        plt.title('SVD of Latent Space')
    
    # Generate samples from latent space
    sample_vecs = latent_means + np.dot(rand_vecs * e, v)
    
    return np.float32(sample_vecs)
    

