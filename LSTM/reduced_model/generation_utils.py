# -*- coding: utf-8 -*-
"""
Created on Wed Apr  8 21:29:08 2020

@author: Mitchell

generation_utils.py
~~~~~~~~~~~~~~~~~~~
This file contains helper functions used to generate original NES music
using our trained model. Primarily it contains the following functions:
    
    1) generate_track:
    - Generates new sequence using our model and an initial seed.
    
    2) generate_seprsco:
    - Parses our generated squences to extract valid seprsco music tracks.
    
"""

import tensorflow as tf
import numpy as np



def generate_track(model, seed, generation_length=1000, num_songs = 3,
                   keep_seed = True, gen_method = 0):
    '''
    This function uses our model to generate an original first melodic voice
    for an NES music track, starting with the given seed. To do so we 
    iteratively select a random new note for our track from the model outpu
    and feed this slection back into the model. We do this until we have
    generated a track of a specified length or until we have encountered a 
    specified number of end-notes generated by our model.

    Parameters
    ----------
    model : tf.keras.Model
        Model we use to generate our NES music track.
    seed : numpy array
        Initial note used to initiate our model and begin our track.
    generation_length : int, optional
        Length of track we want to generate. Only used if gen_method set
        to 0. The default is 1000.
    num_songs : int, optional
        Number of individual tracks we want to generate. Each will begin
        with the specified seed. NOTE - this does not guarantee each track
        generated will be valid. Only used if gen_method set to 1. The
        default is 3.
    keep_seed : Boolean, optional
        Specifies whether to keep the seed at the start of each track we
        generate or to remove it. The default is True.
    gen_method : int/Boolean, optional
        Determines which method is used to generate our new NES music track.
        Method 0 generates a track of a specific length as specified by
        generation_length, while Method 1 generates a specific number of
        individual tracks as specified by num_songs. The default is 0.

    Returns
    -------
    track : numpy array
        Our newly generated NES music track first melodic voice. This sequence
        still needs to be parsed and transformed to extract valid sections and
        to be reformatted as a serpsco music track.

    '''
    # Reset our model state
    model.reset_states()
    
    # Initialize state of model using our seed
    input_eval = seed.copy()[0,0].reshape(1,1)
    for j in range(1,seed.shape[-1]):
        model(input_eval)
        input_eval = seed.copy()[0,j].reshape(1,1)
    
    # Generate our track using given method: fixed length or # of tracks
    if gen_method == 0:
        # Array to store our generated track
        track = np.zeros((generation_length),type(seed[0][0]))
        
        # variables for tracking progress
        interval = 1
        interval_length = generation_length / 10
                
        # Iterate over generation length appending each newly generated note to our track
        for i in range(generation_length):
            # Grab output probabilities for next notes
            predictions = model(input_eval)
            # Remove the batch dimension
            prediction =tf.squeeze(predictions, 0) 
            # Sample from our distribution
            predicted_id = tf.random.categorical(tf.math.log(prediction), num_samples=1)[-1,0].numpy()
        
            # Update the input to pass into the model on next pass
            input_eval = np.array(predicted_id).reshape(1,1)
            
            # Append predicted_id for stream to list
            track[i] = predicted_id
                
            # Print update everytime 10% of track generated
            if (i+1) / interval_length >= interval:
                print('Percent of Track Generated: {}%'.format(interval*10))
                interval += 1
        
        # Add seed if desired           
        if keep_seed:
            track = np.concatenate((seed.copy().reshape(seed.shape[-1]),track))
            
    elif gen_method == 1:
        # Initialize track using seed
        track = seed.copy().reshape(seed.shape[-1])
                
        # Initiate tracks counter
        end_notes = 0
        # Generate new notes until number of songs (number of end notes) created
        while end_notes < num_songs:
            # Grab output probabilities for next notes
            predictions = model(input_eval)
            # Remove the batch dimension
            prediction =tf.squeeze(predictions, 0) 
            # Sample from our distribution
            predicted_id = tf.random.categorical(prediction, num_samples=1)[-1,0].numpy()
        
            # Update the input to pass into the model on next pass
            input_eval = np.array(predicted_id).reshape(1,1)
            
            # Add the predicted note to our track
            track = np.concatenate((track,np.array(predicted_id).reshape(1)))
            # Check to see if end note
            if predicted_id == 77:
                end_notes += 1
                print('Tracks Generated: {}'.format(end_notes))
                # Re-initialize model using seed
                model.reset_states()
                input_eval = seed.copy()[0,0].reshape(1,1)
                for j in range(1,seed.shape[-1]):
                    model(input_eval)
                    input_eval = seed.copy()[0,j].reshape(1,1)
                # Add seed to beginning of new track if desired
                if keep_seed and end_notes < num_songs:
                        track = np.concatenate((track,seed.copy().reshape(seed.shape[-1])))
        
        # remove first seed if desired           
        if not keep_seed:
            track = track[seed.shape[-1]:]
    
    # Check to be sure start and end of track has start/stop note
    start_end = 77
    if track[0] != start_end:
        track = np.concatenate((np.array([start_end]), track))
    if track[-1] != start_end:
        track = np.concatenate((track, np.array([start_end])))
    
    # Print that completed
    print('Track Generation Complete')
    
    return track


def generate_seprsco(track, int2labels_map, min_length = 240):
    '''
    This function is used to parse the output of generate_track to extract
    valid seprsco music tracks. To do so, it searches all start/end notes
    in our track, checks that each sequence between these points is of a valid
    length, then iterates over each sequence to transform it to a seprsco
    format.

    Parameters
    ----------
    track : numpy arrays
        The output sequence generated by our model used to create our own
        original NES music.
    int2labels_map : numpy array
        This is the inverse mapping used to de-vectorize our sequence.
        More simply, it maps our sequence back to the original label values 
        from the integer representations.
    min_length : int, optional
        Minimum length contraint for each output seprsco track. Any sequences
        generated by our model below this value will be discarded. The default
        is 240, which equates to about a 10sec track.

    Returns
    -------
    seprsco_tracks : list of tuples
        List containing each valid seprsco track extracted from our input
        sequence.

    '''
    # Finding indices of all the end notes
    end_indxs = np.where(track == 77)[0]
    
    # Initialize array to store each valid track
    tracks = []
    
    # Iterate over indices to check and grab valid tracks
    # Will also convert from integers back to labels using mapping
    for i in range(len(end_indxs) - 1):
        m , n = end_indxs[i] , end_indxs[i+1]
        if n - m > min_length:
            new_track = int2labels_map[track[m+1:n]]
            tracks.append(new_track)
    
    # Reformat each track to seprsco file
    for i in range(len(tracks)):
        track = tracks[i]
        new_track = np.zeros((track.shape[0],4), np.uint8)
        new_track[:,0] = track
        tracks[i] = new_track.copy()
    seprsco_tracks = []
    for track in tracks:
        # Properly format all required data for seprsco track
        score = track
        nsamps = 1839 * score.shape[0]
        rate = 24.0
        seprsco_tracks.append((rate, nsamps, score))
    
    return seprsco_tracks

