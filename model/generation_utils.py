# -*- coding: utf-8 -*-
"""
Created on Wed Apr  8 21:29:08 2020

@author: Mitchell

generation_utils.py
~~~~~~~~~~~~~~~~~~~
This file contains helper functions used to generate original NES music
using our trained model. Primarily it contains the following functions:
    
    1) generate_track:
    - Generates new sequence using our model and an initial seed.
    
    2) generate_seprsco:
    - Parses our generated squences to extract valid seprsco music tracks.
    
"""

import tensorflow as tf
import numpy as np



def generate_track(model, seed, generation_length=1000, num_songs = 3,
                   keep_seed = True, gen_method = 0):
    '''
    This function uses our model to generate an original NES music track
    starting with the given seed. To do so we iteratively select a random
    new note for our track from the model output and feed this slection back
    into the model. We do this until we have generated a track of a specified
    length or until we have encountered a specified number of end-notes
    generated by our model.

    Parameters
    ----------
    model : tf.keras.Model
        Model we use to generate our NES music track.
    seed : list of numpy arrays
        Initial note(s) used to initiate our model and begin our track.
    generation_length : int, optional
        Length of track we want to generate. Only used if gen_method set
        to 0. The default is 1000.
    num_songs : int, optional
        Number of individual tracks we want to generate. Each will begin
        with the specified seed. NOTE - this does not guarantee each track
        generated will be valid. Only used if gen_method set to 1. The
        default is 3.
    keep_seed : Boolean, optional
        Specifies whether to keep the seed at the start of each track we
        generate or to remove it. The default is True.
    gen_method : int/Boolean, optional
        Determines which method is used to generate our new NES music track.
        Method 0 generates a track of a specific length as specified by
        generation_length, while Method 1 generates a specific number of
        individual tracks as specified by num_songs. The default is 0.

    Returns
    -------
    track : list of numpy arrays
        Our newly generated NES music track. This sequence still needs to be
        parsed and trnsformed to extract valid serpsco music tracks.

    '''
    # Reset our model state
    model.reset_states()
    
    # Initialize state of model using our seed
    input_eval = [seed.copy()[i][0,0].reshape(1,1) for i in range(len(seed))]
    for j in range(1,seed[0].shape[-1]):
        model(input_eval)
        input_eval = [seed.copy()[i][0,j].reshape(1,1) for i in range(len(seed))]
    
    # Generate our track using given method: fixed length or # of tracks
    if gen_method == 0:
        # Array to store our generated track
        track = [np.zeros((generation_length),type(seed[0][0][0])) for i in range(len(seed))]
        
        # variables for tracking progress
        interval = 1
        interval_length = generation_length / 10
                
        # Iterate over generation length appending each newly generated note to our track
        for i in range(generation_length):
            # Grab output probabilities for next notes
            predictions = model(input_eval)
            
            # Grabbing id for next note in each stream by sampling from our distr.
            for j in range(len(predictions)):
                # Grab predictions for stream and remove the batch dimension
                prediction =tf.squeeze(predictions[j], 0) 
                # Sample from our distribution
                predicted_id = tf.random.categorical(tf.math.log(prediction), num_samples=1)[-1,0].numpy()
            
                # Update the input to pass into the model on next pass
                input_eval[j] = np.array(predicted_id).reshape(1,1)
                
                # Append predicted_id for stream to list
                track[j][i] = predicted_id
                
            # Print update everytime 10% of track generated
            if (i+1) / interval_length >= interval:
                print('Percent of Track Generated: {}%'.format(interval*10))
                interval += 1
        
        # Add seed if desired           
        if keep_seed:
            for i in range(len(track)):
                track[i] = np.concatenate((seed.copy()[i].reshape(seed[i].shape[-1]),track[i]))
            
    elif gen_method == 1:
        # Empty array to store our generated track
        track = [None for i in range(len(seed))]
        # Add seed is desired
        for i in range(len(seed)):
            track[i] = seed.copy()[i].reshape(seed[i].shape[-1])
                
        # Initiate tracks counter
        end_notes = 0
        # Generate new notes until number of songs (number of end notes) created
        while end_notes < num_songs:
            # Grab output probabilities for next notes
            predictions = model(input_eval)
            
            # Grabbing id for next note in each stream by sampling from our distr.
            predicted_ids =[]
            for i in range(len(predictions)):
                # Grab predictions for stream and remove the batch dimension
                prediction =tf.squeeze(predictions[i], 0) 
                # Sample from our distribution
                predicted_id = tf.random.categorical(prediction, num_samples=1)[-1,0].numpy()
            
                # Update the input to pass into the model on next pass
                input_eval[i] = np.array(predicted_id).reshape(1,1)
                
                # Append predicted_id for stream to list
                predicted_ids.append(predicted_id)
            
            # Add the predicted notes for each stream to our song
            for i in range(len(seed)):
                track[i] = np.concatenate((track[i],np.array(predicted_ids[i]).reshape(1)))
                # Check to see if end note
                if i == 4 and predicted_ids[i] == 0:
                    end_notes += 1
                    print('Tracks Generated: {}'.format(end_notes))
                    # Re-initialize model using seed
                    model.reset_states()
                    input_eval = [seed.copy()[i][0,0].reshape(1,1) for i in range(len(seed))]
                    for j in range(1,seed[0].shape[-1]):
                        model(input_eval)
                        input_eval = [seed.copy()[i][0,j].reshape(1,1) for i in range(len(seed))]
                    # Add seed to beginning of new track if desired
                    if keep_seed and end_notes < num_songs:
                        for i in range(len(track)):
                            track[i] = np.concatenate((track[i],seed.copy()[i].reshape(seed[i].shape[-1])))
        
        # remove first seed if desired           
        if not keep_seed:
            for i in range(len(track)):
                track[i] = track[i][seed[0].shape[-1]:]
    
    # Check to be sure start and end of track has start/stop note
    start_end = [np.zeros((1,),int) for i in range(5)]
    if track[len(track)-1][0] != 0:
        for i in range(len(track)):
            track[i] = np.concatenate((start_end[i], track[i]))
    if track[len(track)-1][-1] != 0:
        for i in range(len(track)):
            track[i] = np.concatenate((track[i], start_end[i]))
    
    # Print that completed
    print('Track Generation Complete')
    
    return track


def generate_seprsco(track, int2labels_maps, min_length = 240):
    '''
    This function is used to parse the output of generate_track to extract
    valid seprsco music tracks. To do so, it searches all start/end notes
    in our track, checks that each sequence between these points is of a valid
    length, then iterates over each sequence to transform it to a seprsco
    format.

    Parameters
    ----------
    track : list of numpy arrays
        The output sequence generated by our model used to create our own
        original NES music.
    int2labels_maps : list of numpy arrays
        These are the inverse mappings used to de-vectorize our sequences.
        More simply, thes mappings are used to transform our sequences back
        to their original label values from the integer representations.
    min_length : int, optional
        Minimum length contraint for each output seprsco track. Any sequences
        generated by our model below this value will be discarded. The default
        is 240, which equates to about a 10sec track.

    Returns
    -------
    seprsco_tracks : list of tuples
        List containing each valid seprsco track extracted from our input
        sequence.

    '''
    # Finding indices of all the end notes
    end_indxs = np.where(track[-1] == 0)[0]
    
    # Initialize array to store each valid track
    tracks = []
    
    # Iterate over indices to check and grab valid tracks
    # Will also convert from integers back to labels using mapping
    for i in range(len(end_indxs) - 1):
        m , n = end_indxs[i] , end_indxs[i+1]
        if n - m > min_length:
            new_track = []
            for j in range(len(track)):
                new_track.append(int2labels_maps[j][track[j][m+1:n]])
            tracks.append(new_track)
    
    # Reformat each track to seprsco file
    seprsco_tracks = []
    for track in tracks:
        track = track[:-1]
        n , m = len(track) , track[0].shape[0]
        score = []
        for i in range(m):
            note = []
            for j in range(n):
                note.append(track[j][i])
            score.append(note)
        # Properly format all required data for seprsco track
        score = np.array(score, np.uint8)
        nsamps = 1839 * score.shape[0]
        rate = 24.0
        seprsco_tracks.append((rate, nsamps, score))
    
    return seprsco_tracks

